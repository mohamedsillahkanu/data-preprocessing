<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Data Quality Assessment Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #f8f9ff, #e8edff);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, #e8edff, #f8f9ff);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .file-info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .main-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        select, input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .quality-report {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .quality-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .quality-stat {
            background: linear-gradient(135deg, #f8f9ff, #e8edff);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border-left: 4px solid #667eea;
        }

        .quality-stat.critical {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #ffeaa7, #fab1a0);
        }

        .quality-stat.warning {
            border-left-color: #ffc107;
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        }

        .quality-stat.good {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
        }

        .quality-stat h5 {
            color: #333;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .quality-stat .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }

        .column-report {
            margin-bottom: 25px;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
        }

        .column-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .column-content {
            padding: 20px;
        }

        .issue-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .issue-card {
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid;
        }

        .issue-card.critical {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }

        .issue-card.warning {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }

        .issue-card.info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
            color: #0c5460;
        }

        .issue-card.success {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }

        .issue-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .issue-description {
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .issue-details {
            font-size: 0.85rem;
            background: rgba(255,255,255,0.5);
            padding: 8px;
            border-radius: 6px;
        }

        .samples-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(255,255,255,0.7);
            padding: 10px;
            border-radius: 6px;
            margin-top: 8px;
        }

        .sample-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: white;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .fix-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .fix-button:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .overall-score {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            margin-bottom: 25px;
        }

        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .progress-indicator {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: #28a745;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .data-table {
            overflow: auto;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            margin-top: 20px;
            max-height: 400px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 15px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9ff);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }

        .error {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .info {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 Complete Data Quality Assessment Tool</h1>
            <p>Upload your data files and get a comprehensive quality analysis with detailed column-by-column reporting</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <h3>Drop your Excel or CSV file here or click to browse</h3>
                <p>Supports .xlsx, .xls, .csv files up to 50MB</p>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls,.csv">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose File
                </button>
            </div>
            <div id="fileInfo" class="file-info" style="display: none;"></div>
        </div>

        <div class="main-section">
            <h2>📊 Data Quality Assessment</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="dataSheet">Select Sheet:</label>
                    <select id="dataSheet" onchange="updateOverview()"></select>
                </div>
                <div class="control-group" style="display: flex; align-items: end;">
                    <button class="btn" onclick="runComprehensiveDataCheck()">🔍 Run Complete Data Quality Check</button>
                </div>
            </div>
            
            <div id="overviewStats" class="stats-grid"></div>
            <div id="dataQualityReport"></div>
        </div>
    </div>

    <script>
        // Global variables
        let workbookData = {};
        let processedData = {};

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');

        // Initialize drag and drop functionality
        function initializeFileUpload() {
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#28a745';
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#667eea';
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#667eea';
                const files = e.dataTransfer.files;
                handleFiles(files);
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
        }

        function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.match(/\.(xlsx|xls|csv)$/)) {
                showError('Please select a valid Excel (.xlsx, .xls) or CSV (.csv) file');
                return;
            }

            if (file.size > 50 * 1024 * 1024) {
                showError('File size must be less than 50MB');
                return;
            }

            // Check if it's a CSV file
            if (file.name.toLowerCase().endsWith('.csv')) {
                processCSVFile(file);
            } else {
                processExcelFile(file);
            }
        }

        function processCSVFile(file) {
            fileInfo.innerHTML = '<div class="info">Processing CSV file...</div>';
            fileInfo.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    
                    Papa.parse(csvText, {
                        header: false,
                        skipEmptyLines: true,
                        dynamicTyping: false,
                        complete: function(results) {
                            try {
                                if (results.errors.length > 0) {
                                    console.warn('CSV parsing warnings:', results.errors);
                                }

                                const data = results.data;
                                if (data.length === 0) {
                                    showError('CSV file appears to be empty');
                                    return;
                                }

                                const sheetName = file.name.replace(/\.csv$/i, '');
                                workbookData = {};
                                processedData = {};
                                workbookData[sheetName] = data;
                                processedData[sheetName] = JSON.parse(JSON.stringify(data));

                                const totalRows = data.length;
                                const totalColumns = data.length > 0 ? Math.max(...data.map(row => row.length)) : 0;

                                fileInfo.innerHTML = `
                                    <div class="success">
                                        <strong>✅ CSV file loaded successfully!</strong><br>
                                        📁 ${file.name} (${formatFileSize(file.size)})<br>
                                        📄 1 sheet, ${totalRows} rows, ${totalColumns} columns
                                    </div>
                                `;

                                populateSheetDropdowns();
                                updateOverview();
                            } catch (error) {
                                showError('Error processing CSV data: ' + error.message);
                            }
                        },
                        error: function(error) {
                            showError('Error parsing CSV file: ' + error.message);
                        }
                    });
                } catch (error) {
                    showError('Error reading CSV file: ' + error.message);
                }
            };

            reader.readAsText(file);
        }

        function processExcelFile(file) {
            const reader = new FileReader();
            
            fileInfo.innerHTML = '<div class="info">Processing Excel file...</div>';
            fileInfo.style.display = 'block';

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    workbookData = {};
                    processedData = {};
                    let totalRows = 0;
                    let totalColumns = 0;

                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                        
                        const filteredData = jsonData.filter(row => row.some(cell => cell !== undefined && cell !== ''));
                        
                        if (filteredData.length > 0) {
                            workbookData[sheetName] = filteredData;
                            processedData[sheetName] = JSON.parse(JSON.stringify(filteredData));
                            totalRows += filteredData.length;
                            totalColumns = Math.max(totalColumns, Math.max(...filteredData.map(row => row.length)));
                        }
                    });

                    fileInfo.innerHTML = `
                        <div class="success">
                            <strong>✅ Excel file loaded successfully!</strong><br>
                            📁 ${file.name} (${formatFileSize(file.size)})<br>
                            📄 ${Object.keys(workbookData).length} sheets, ${totalRows} rows, ${totalColumns} columns
                        </div>
                    `;

                    populateSheetDropdowns();
                    updateOverview();
                    
                } catch (error) {
                    showError('Error processing file: ' + error.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function populateSheetDropdowns() {
            const sheetNames = Object.keys(workbookData);
            const select = document.getElementById('dataSheet');
            
            select.innerHTML = '';
            sheetNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function updateOverview() {
            const sheetName = document.getElementById('dataSheet').value;
            if (!sheetName || !workbookData[sheetName]) return;

            const data = workbookData[sheetName];
            const headers = data[0] || [];
            const rows = data.slice(1);

            // Update stats
            const statsHtml = `
                <div class="stat-card">
                    <h4>📊 Total Rows</h4>
                    <div class="stat-value">${rows.length.toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <h4>📋 Total Columns</h4>
                    <div class="stat-value">${headers.length}</div>
                </div>
                <div class="stat-card">
                    <h4>📝 Text Columns</h4>
                    <div class="stat-value">${countColumnsByType(data, 'text')}</div>
                </div>
                <div class="stat-card">
                    <h4>🔢 Numeric Columns</h4>
                    <div class="stat-value">${countColumnsByType(data, 'numeric')}</div>
                </div>
            `;
            document.getElementById('overviewStats').innerHTML = statsHtml;
        }



        function countColumnsByType(data, type) {
            if (data.length < 2) return 0;
            
            const headers = data[0];
            const rows = data.slice(1);
            let count = 0;

            headers.forEach((header, index) => {
                const columnData = rows.map(row => row[index]).filter(val => val !== undefined && val !== '');
                if (columnData.length > 0) {
                    const analysis = analyzeDataType(columnData);
                    if ((type === 'numeric' && analysis.type === 'Numeric') || 
                        (type === 'text' && analysis.type === 'Text')) {
                        count++;
                    }
                }
            });

            return count;
        }

        // Comprehensive Data Quality Check
        function runComprehensiveDataCheck() {
            const sheetName = document.getElementById('dataSheet').value;
            if (!sheetName || !workbookData[sheetName]) {
                showError('Please select a sheet to analyze');
                return;
            }

            showMessage('Running comprehensive data quality analysis...', 'info');

            const data = workbookData[sheetName];
            if (data.length < 2) {
                showError('Sheet must have at least 2 rows (header + data)');
                return;
            }

            const headers = data[0];
            const rows = data.slice(1);
            
            const qualityReport = {
                sheet: sheetName,
                totalRows: rows.length,
                totalColumns: headers.length,
                issues: [],
                columnReports: {},
                overallScore: 0,
                criticalIssues: 0,
                warningIssues: 0,
                infoIssues: 0
            };

            headers.forEach((header, columnIndex) => {
                const columnData = rows.map(row => row[columnIndex]);
                const columnReport = analyzeColumnQuality(header, columnData, columnIndex, rows.length);
                qualityReport.columnReports[header] = columnReport;
                
                columnReport.issues.forEach(issue => {
                    switch(issue.severity) {
                        case 'critical':
                            qualityReport.criticalIssues++;
                            break;
                        case 'warning':
                            qualityReport.warningIssues++;
                            break;
                        case 'info':
                            qualityReport.infoIssues++;
                            break;
                    }
                });
            });

            const totalPossibleIssues = headers.length * 10;
            const totalIssues = qualityReport.criticalIssues * 3 + qualityReport.warningIssues * 2 + qualityReport.infoIssues;
            qualityReport.overallScore = Math.max(0, Math.round(100 - (totalIssues / totalPossibleIssues) * 100));

            displayQualityReport(qualityReport);
            showMessage('Data quality analysis completed!', 'success');
        }

        function analyzeColumnQuality(columnName, columnData, columnIndex, totalRows) {
            const report = {
                name: columnName,
                index: columnIndex,
                totalValues: columnData.length,
                nonEmptyValues: columnData.filter(v => v !== undefined && v !== '' && v !== null).length,
                uniqueValues: [...new Set(columnData.filter(v => v !== undefined && v !== '' && v !== null))].length,
                dataType: 'Unknown',
                issues: []
            };

            const nonEmptyData = columnData.filter(v => v !== undefined && v !== '' && v !== null);
            
            // 1. Check for unnamed/problematic column names
            if (!columnName || 
                columnName.toString().includes('Unnamed') || 
                columnName.toString().includes('Column') || 
                columnName.toString().trim() === '' ||
                columnName.toString().startsWith('__EMPTY')) {
                report.issues.push({
                    type: 'Unnamed Column',
                    severity: 'critical',
                    description: 'Column has no proper name or contains generic naming',
                    count: 1,
                    suggestion: 'Rename column with descriptive name or remove',
                    canFix: true,
                    fixAction: 'removeUnnamedColumns'
                });
            }

            // 2. Check for missing values
            const missingCount = totalRows - report.nonEmptyValues;
            if (missingCount > 0) {
                const missingPercentage = (missingCount / totalRows) * 100;
                const severity = missingPercentage > 50 ? 'critical' : missingPercentage > 20 ? 'warning' : 'info';
                report.issues.push({
                    type: 'Missing Values',
                    severity: severity,
                    description: `${missingCount} missing values (${missingPercentage.toFixed(1)}%)`,
                    count: missingCount,
                    suggestion: missingPercentage > 50 ? 'Consider removing column or imputing values' : 'Review missing data pattern',
                    canFix: false
                });
            }

            if (nonEmptyData.length === 0) {
                report.issues.push({
                    type: 'Empty Column',
                    severity: 'critical',
                    description: 'Column contains no data',
                    count: totalRows,
                    suggestion: 'Remove empty column',
                    canFix: true,
                    fixAction: 'removeUnnamedColumns'
                });
                return report;
            }

            // 3. Analyze data type and consistency
            const typeAnalysis = analyzeDataType(nonEmptyData);
            report.dataType = typeAnalysis.type;

            if (typeAnalysis.confidence < 90) {
                report.issues.push({
                    type: 'Inconsistent Data Types',
                    severity: 'warning',
                    description: `Mixed data types detected (${typeAnalysis.confidence}% confidence)`,
                    count: Math.round(nonEmptyData.length * (100 - typeAnalysis.confidence) / 100),
                    suggestion: `Consider converting to ${typeAnalysis.type}`,
                    canFix: typeAnalysis.convertible,
                    fixAction: 'convertDataType',
                    samples: typeAnalysis.inconsistentSamples || []
                });
            }

            // 4. Check for leading/trailing spaces
            const spacesCount = nonEmptyData.filter(val => 
                typeof val === 'string' && val !== val.trim()
            ).length;
            
            if (spacesCount > 0) {
                report.issues.push({
                    type: 'Leading/Trailing Spaces',
                    severity: 'warning',
                    description: `${spacesCount} values have unnecessary spaces`,
                    count: spacesCount,
                    suggestion: 'Remove leading and trailing spaces',
                    canFix: true,
                    fixAction: 'trimSpaces',
                    samples: nonEmptyData.filter(val => 
                        typeof val === 'string' && val !== val.trim()
                    ).slice(0, 5).map(val => `"${val}"`)
                });
            }

            // 5. Check for accented characters
            const accentCount = nonEmptyData.filter(val => 
                typeof val === 'string' && /[àáâãäåæçèéêëìíîïðñòóôõöøùúûüýÿ]/i.test(val)
            ).length;
            
            if (accentCount > 0) {
                report.issues.push({
                    type: 'Accented Characters',
                    severity: 'info',
                    description: `${accentCount} values contain accented characters`,
                    count: accentCount,
                    suggestion: 'Consider removing accents for consistency',
                    canFix: true,
                    fixAction: 'removeAccents',
                    samples: nonEmptyData.filter(val => 
                        typeof val === 'string' && /[àáâãäåæçèéêëìíîïðñòóôõöøùúûüýÿ]/i.test(val)
                    ).slice(0, 5)
                });
            }

            // 6. Check for special characters (.?/)
            const specialCharCount = nonEmptyData.filter(val => 
                typeof val === 'string' && /[.?/]/.test(val)
            ).length;
            
            if (specialCharCount > 0) {
                report.issues.push({
                    type: 'Special Characters',
                    severity: 'info',
                    description: `${specialCharCount} values contain special characters (.?/)`,
                    count: specialCharCount,
                    suggestion: 'Remove special characters if not needed',
                    canFix: true,
                    fixAction: 'removeSpecialCharacters',
                    samples: nonEmptyData.filter(val => 
                        typeof val === 'string' && /[.?/]/.test(val)
                    ).slice(0, 5)
                });
            }

            // 7. Check for numeric values stored as text (Value Specification)
            if (typeAnalysis.type === 'Text') {
                const numericAsTextCount = nonEmptyData.filter(val => 
                    typeof val === 'string' && !isNaN(parseFloat(val.replace(/[,\s]/g, ''))) && val.trim() !== ''
                ).length;
                
                if (numericAsTextCount > nonEmptyData.length * 0.5) {
                    report.issues.push({
                        type: 'Numbers Stored as Text',
                        severity: 'warning',
                        description: `${numericAsTextCount} numeric values stored as text`,
                        count: numericAsTextCount,
                        suggestion: 'Convert to numeric data type for proper calculations',
                        canFix: true,
                        fixAction: 'convertToNumeric',
                        samples: nonEmptyData.filter(val => 
                            typeof val === 'string' && !isNaN(parseFloat(val.replace(/[,\s]/g, ''))) && val.trim() !== ''
                        ).slice(0, 5)
                    });
                }
            }

            // 8. Data Uniqueness Check for Categorical Variables
            if (typeAnalysis.type === 'Text' && report.uniqueValues < report.nonEmptyValues) {
                const duplicateCount = report.nonEmptyValues - report.uniqueValues;
                const duplicatePercentage = (duplicateCount / report.nonEmptyValues) * 100;
                
                if (duplicatePercentage > 10) {
                    const severity = duplicatePercentage > 50 ? 'warning' : 'info';
                    
                    // Get unique values in alphabetical order
                    const uniqueValues = [...new Set(nonEmptyData.map(v => String(v)))].sort();
                    const valueCounts = {};
                    nonEmptyData.forEach(val => {
                        const strVal = String(val);
                        valueCounts[strVal] = (valueCounts[strVal] || 0) + 1;
                    });

                    report.issues.push({
                        type: 'Duplicate Values',
                        severity: severity,
                        description: `${duplicateCount} duplicate values (${duplicatePercentage.toFixed(1)}%)`,
                        count: duplicateCount,
                        suggestion: 'Review for data entry errors or consolidation opportunities',
                        canFix: false,
                        uniqueValuesAlphabetical: uniqueValues.map(val => ({
                            value: val,
                            count: valueCounts[val]
                        }))
                    });
                }
            }

            // 9. Similarity Check for Categorical Variables
            if (typeAnalysis.type === 'Text' && report.uniqueValues > 2 && report.uniqueValues < 100) {
                const uniqueValues = [...new Set(nonEmptyData.map(v => String(v)))];
                const similarPairs = [];
                
                for (let i = 0; i < uniqueValues.length && i < 50; i++) {
                    for (let j = i + 1; j < uniqueValues.length && j < 50; j++) {
                        const similarity = calculateSimilarity(uniqueValues[i], uniqueValues[j]);
                        if (similarity >= 0.75 && similarity < 1) {
                            similarPairs.push({
                                value1: uniqueValues[i],
                                value2: uniqueValues[j],
                                similarity: similarity
                            });
                        }
                    }
                }
                
                if (similarPairs.length > 0) {
                    report.issues.push({
                        type: 'Similar Values',
                        severity: 'info',
                        description: `${similarPairs.length} pairs of similar values detected`,
                        count: similarPairs.length,
                        suggestion: 'Check for spelling variations or data entry errors',
                        canFix: false,
                        similarPairs: similarPairs.slice(0, 10) // Limit to first 10 pairs
                    });
                }
            }

            return report;
        }

        function analyzeDataType(columnData) {
            if (columnData.length === 0) {
                return { type: 'Empty', confidence: 100, issues: [], convertible: false };
            }

            let numCount = 0;
            let boolCount = 0;
            let issues = [];
            let inconsistentSamples = [];

            columnData.forEach(val => {
                const strVal = String(val).trim();
                
                if (!isNaN(strVal) && strVal !== '') {
                    numCount++;
                } else if (isNaN(strVal) && /^[\d,\s.]+$/.test(strVal)) {
                    numCount++;
                    issues.push('Numbers with formatting (commas, spaces)');
                    inconsistentSamples.push(strVal);
                }
                
                if (['true', 'false', 'yes', 'no', '1', '0'].includes(strVal.toLowerCase())) {
                    boolCount++;
                }

                if (inconsistentSamples.length < 5 && 
                    typeof val === 'string' && 
                    (val !== val.trim() || /[àáâãäåæçèéêëìíîïðñòóôõöøùúûüýÿ]/i.test(val) || /[.?/]/.test(val))) {
                    inconsistentSamples.push(val);
                }
            });

            const total = columnData.length;
            const numPercent = (numCount / total) * 100;
            const boolPercent = (boolCount / total) * 100;

            let type, confidence, recommendedType, convertible = false;

            if (numPercent >= 80) {
                type = 'Numeric';
                confidence = Math.round(numPercent);
                if (numPercent < 100) {
                    recommendedType = 'Number';
                    convertible = true;
                }
            } else if (boolPercent >= 80) {
                type = 'Boolean';
                confidence = Math.round(boolPercent);
                recommendedType = 'Boolean';
                convertible = true;
            } else {
                type = 'Text';
                confidence = Math.round(Math.max(100 - numPercent - boolPercent, 0));
            }

            return { 
                type, 
                confidence, 
                issues: [...new Set(issues)], 
                convertible, 
                recommendedType,
                inconsistentSamples: [...new Set(inconsistentSamples)]
            };
        }





        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function displayQualityReport(report) {
            let html = `
                <div class="quality-report">
                    <div class="overall-score">
                        <div class="score-circle">${report.overallScore}</div>
                        <h3>Overall Data Quality Score</h3>
                        <p>Based on ${Object.keys(report.columnReports).length} columns and ${report.totalRows} rows</p>
                        <div class="progress-indicator">
                            <div class="progress-fill" style="width: ${report.overallScore}%"></div>
                        </div>
                    </div>

                    <div class="quality-summary">
                        <div class="quality-stat critical">
                            <h5>Critical Issues</h5>
                            <div class="value">${report.criticalIssues}</div>
                        </div>
                        <div class="quality-stat warning">
                            <h5>Warning Issues</h5>
                            <div class="value">${report.warningIssues}</div>
                        </div>
                        <div class="quality-stat info">
                            <h5>Info Issues</h5>
                            <div class="value">${report.infoIssues}</div>
                        </div>
                        <div class="quality-stat good">
                            <h5>Clean Columns</h5>
                            <div class="value">${Object.values(report.columnReports).filter(col => col.issues.length === 0).length}</div>
                        </div>
                    </div>

                    <h3>📊 Column-by-Column Analysis</h3>
            `;

            const sortedColumns = Object.values(report.columnReports).sort((a, b) => {
                const aScore = a.issues.filter(i => i.severity === 'critical').length * 3 + 
                              a.issues.filter(i => i.severity === 'warning').length * 2 + 
                              a.issues.filter(i => i.severity === 'info').length;
                const bScore = b.issues.filter(i => i.severity === 'critical').length * 3 + 
                              b.issues.filter(i => i.severity === 'warning').length * 2 + 
                              b.issues.filter(i => i.severity === 'info').length;
                return bScore - aScore;
            });

            sortedColumns.forEach(columnReport => {
                const issueCount = columnReport.issues.length;
                const criticalCount = columnReport.issues.filter(i => i.severity === 'critical').length;
                const warningCount = columnReport.issues.filter(i => i.severity === 'warning').length;
                
                const statusColor = criticalCount > 0 ? '#dc3545' : warningCount > 0 ? '#ffc107' : '#28a745';
                const statusText = criticalCount > 0 ? 'Critical Issues' : warningCount > 0 ? 'Needs Attention' : 'Good Quality';

                html += `
                    <div class="column-report">
                        <div class="column-header">
                            <div>
                                <strong>${columnReport.name}</strong>
                                <span style="opacity: 0.9; margin-left: 10px;">
                                    ${columnReport.dataType} | ${columnReport.nonEmptyValues}/${columnReport.totalValues} values | 
                                    ${columnReport.uniqueValues} unique
                                </span>
                            </div>
                            <div style="background: ${statusColor}; padding: 4px 12px; border-radius: 15px; font-size: 0.85rem;">
                                ${statusText} ${issueCount > 0 ? `(${issueCount})` : ''}
                            </div>
                        </div>
                        <div class="column-content">
                `;

                if (columnReport.issues.length === 0) {
                    html += `
                        <div class="issue-card success">
                            <div class="issue-title">
                                ✅ No Issues Found
                            </div>
                            <div class="issue-description">
                                This column has good data quality with no detected issues.
                            </div>
                        </div>
                    `;
                } else {
                    html += '<div class="issue-grid">';
                    
                    columnReport.issues.forEach(issue => {
                        html += `
                            <div class="issue-card ${issue.severity}">
                                <div class="issue-title">
                                    ${issue.severity === 'critical' ? '🔴' : issue.severity === 'warning' ? '🟡' : 'ℹ️'}
                                    ${issue.type}
                                </div>
                                <div class="issue-description">${issue.description}</div>
                                <div class="issue-details">
                                    <strong>Suggestion:</strong> ${issue.suggestion}
                                    ${issue.count ? `<br><strong>Affected:</strong> ${issue.count} values` : ''}
                                </div>
                                ${issue.samples && issue.samples.length > 0 ? `
                                    <div class="samples-list">
                                        <strong>Examples:</strong>
                                        ${issue.samples.map(sample => `<div class="sample-item">${sample}</div>`).join('')}
                                    </div>
                                ` : ''}
                                ${issue.uniqueValuesAlphabetical ? `
                                    <div class="samples-list">
                                        <strong>All Unique Values (Alphabetical):</strong>
                                        ${issue.uniqueValuesAlphabetical.map(item => 
                                            `<div class="sample-item">${item.value} (${item.count} times)</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                                ${issue.similarPairs ? `
                                    <div class="samples-list">
                                        <strong>Similar Value Pairs:</strong>
                                        ${issue.similarPairs.map(pair => 
                                            `<div class="sample-item">"${pair.value1}" ↔ "${pair.value2}" (${(pair.similarity * 100).toFixed(1)}% similar)</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }

                html += '</div></div>';
            });

            html += '</div>';
            
            document.getElementById('dataQualityReport').innerHTML = html;
        }

        // Utility functions
        function showError(message) {
            fileInfo.innerHTML = `<div class="error">❌ ${message}</div>`;
            fileInfo.style.display = 'block';
            
            setTimeout(() => {
                fileInfo.style.display = 'none';
            }, 5000);
        }

        function showMessage(message, type) {
            const className = type === 'success' ? 'success' : (type === 'info' ? 'info' : 'error');
            const icon = type === 'success' ? '✅' : (type === 'info' ? 'ℹ️' : '❌');
            
            fileInfo.innerHTML = `<div class="${className}">${icon} ${message}</div>`;
            fileInfo.style.display = 'block';
            
            setTimeout(() => {
                fileInfo.style.display = 'none';
            }, 3000);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Complete Data Quality Assessment Tool loaded successfully');
            initializeFileUpload();
        });
    </script>
</body>
</html>
