<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Management & Analysis Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #f8f9ff, #e8edff);
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, #e8edff, #f8f9ff);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.2);
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: linear-gradient(45deg, #e8f5e8, #f0f8f0);
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            min-width: 150px;
            padding: 15px 20px;
            text-align: center;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            color: white;
            font-weight: 600;
            position: relative;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, #ffffff, #f8f9ff);
            color: #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .tab-content {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .data-table {
            overflow-x: auto;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 15px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: #f8f9ff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9ff);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .chart-container {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        select, input {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #667eea;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .wrangling-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .wrangling-section h3 {
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .outlier-summary {
            background: linear-gradient(135deg, #f8f9ff, #e8edff);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }

        .data-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .data-type-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }

        .quality-issue {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }

        .quality-pass {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Data Management & Analysis Tool</h1>
            <p>Upload Excel files and perform comprehensive data analysis with interactive visualizations</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <h3>Drop your Excel file here or click to browse</h3>
                <p>Supports .xlsx, .xls files up to 50MB</p>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls" multiple>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose Files
                </button>
            </div>
            <div id="fileInfo" class="file-info" style="display: none;"></div>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('overview')">üìã Overview</div>
            <div class="tab" onclick="switchTab('wrangling')">üîß Data Wrangling</div>
            <div class="tab" onclick="switchTab('statistics')">üìà Statistics</div>
            <div class="tab" onclick="switchTab('charts')">üìä Charts</div>
            <div class="tab" onclick="switchTab('pivot')">üîÑ Pivot Analysis</div>
            <div class="tab" onclick="switchTab('export')">üíæ Export</div>
        </div>

        <!-- Overview Tab -->
        <div id="overview" class="tab-content active">
            <h2>üìã Data Overview</h2>
            <div id="dataPreview"></div>
        </div>

        <!-- Data Wrangling Tab -->
        <div id="wrangling" class="tab-content">
            <h2>üîß Data Wrangling & Cleaning</h2>
            
            <!-- Data Quality Section -->
            <div class="wrangling-section">
                <h3>üîç Data Quality Checks</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="wranglingSheet">Select Sheet:</label>
                        <select id="wranglingSheet" onchange="updateWranglingSheet()"></select>
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="runDataQualityCheck()">Run Quality Check</button>
                        <button class="btn btn-secondary" onclick="detectDataTypes()">Detect Data Types</button>
                    </div>
                </div>
                <div id="dataQualityResults"></div>
            </div>

            <!-- Column Operations Section -->
            <div class="wrangling-section">
                <h3>üìã Column Operations</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="renameColumn">Rename Column:</label>
                        <select id="renameColumn"></select>
                        <input type="text" id="newColumnName" placeholder="New column name">
                        <button class="btn btn-secondary" onclick="renameColumn()">Rename</button>
                    </div>
                    <div class="control-group">
                        <label for="sortColumn">Sort by Column:</label>
                        <select id="sortColumn"></select>
                        <select id="sortOrder">
                            <option value="asc">Ascending</option>
                            <option value="desc">Descending</option>
                        </select>
                        <button class="btn btn-secondary" onclick="sortByColumn()">Sort</button>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <button class="btn btn-secondary" onclick="removeUnnamedColumns()">Remove Unnamed Columns</button>
                        <button class="btn btn-secondary" onclick="removeSpecialCharacters()">Remove Special Characters (.?/)</button>
                        <button class="btn btn-secondary" onclick="trimSpaces()">Trim Leading/Trailing Spaces</button>
                        <button class="btn btn-secondary" onclick="removeAccents()">Remove Accents</button>
                    </div>
                </div>
            </div>

            <!-- Value Operations Section -->
            <div class="wrangling-section">
                <h3>‚úèÔ∏è Value Operations</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="valueColumn">Select Column:</label>
                        <select id="valueColumn"></select>
                    </div>
                    <div class="control-group">
                        <label for="oldValue">Old Value:</label>
                        <input type="text" id="oldValue" placeholder="Value to replace">
                    </div>
                    <div class="control-group">
                        <label for="newValue">New Value:</label>
                        <input type="text" id="newValue" placeholder="New value">
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="replaceValues()">Replace Values</button>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="dateColumn">Date Column:</label>
                        <select id="dateColumn"></select>
                    </div>
                    <div class="control-group">
                        <label for="dateFormat">Target Format:</label>
                        <select id="dateFormat">
                            <option value="yyyy-mm-dd">YYYY-MM-DD</option>
                            <option value="dd/mm/yyyy">DD/MM/YYYY</option>
                            <option value="mm/dd/yyyy">MM/DD/YYYY</option>
                            <option value="dd-mm-yyyy">DD-MM-YYYY</option>
                            <option value="iso">ISO 8601</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="standardizeDates()">Standardize Dates</button>
                    </div>
                </div>
            </div>

            <!-- Outlier Detection Section -->
            <div class="wrangling-section">
                <h3>üìä Outlier Detection & Removal</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="outlierColumn">Numeric Column:</label>
                        <select id="outlierColumn"></select>
                    </div>
                    <div class="control-group">
                        <label for="outlierMethod">Detection Method:</label>
                        <select id="outlierMethod">
                            <option value="iqr">IQR (Interquartile Range)</option>
                            <option value="zscore">Z-Score</option>
                            <option value="modified_zscore">Modified Z-Score</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="outlierAction">Action:</label>
                        <select id="outlierAction">
                            <option value="detect">Detect Only</option>
                            <option value="remove">Remove</option>
                            <option value="cap">Cap (Winsorize)</option>
                            <option value="median">Replace with Median</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="groupByColumn">Group By (Optional):</label>
                        <select id="groupByColumn">
                            <option value="">No Grouping</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="handleOutliers()">Process Outliers</button>
                    </div>
                </div>
                <div id="outlierResults"></div>
            </div>

            <!-- Data Creation Section -->
            <div class="wrangling-section">
                <h3>‚ûï Create New Columns</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="newColName">New Column Name:</label>
                        <input type="text" id="newColName" placeholder="Enter column name">
                    </div>
                    <div class="control-group">
                        <label for="groupByCol">Group By:</label>
                        <select id="groupByCol"></select>
                    </div>
                    <div class="control-group">
                        <label for="aggregateCol">Aggregate Column:</label>
                        <select id="aggregateCol"></select>
                    </div>
                    <div class="control-group">
                        <label for="aggregateFunction">Function:</label>
                        <select id="aggregateFunction">
                            <option value="sum">Sum</option>
                            <option value="average">Average</option>
                            <option value="count">Count</option>
                            <option value="min">Minimum</option>
                            <option value="max">Maximum</option>
                            <option value="percentage">Percentage of Total</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="createAggregateColumn()">Create Column</button>
                    </div>
                </div>
            </div>

            <!-- Uniqueness & Similarity Check Section -->
            <div class="wrangling-section">
                <h3>üîç Uniqueness & Similarity Analysis</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="uniqueColumn">Categorical Column:</label>
                        <select id="uniqueColumn"></select>
                    </div>
                    <div class="control-group">
                        <label for="similarityThreshold">Similarity Threshold (0-1):</label>
                        <input type="number" id="similarityThreshold" value="0.8" min="0" max="1" step="0.1">
                    </div>
                    <div class="control-group">
                        <button class="btn" onclick="checkUniqueness()">Check Uniqueness</button>
                        <button class="btn btn-secondary" onclick="findSimilarValues()">Find Similar Values</button>
                    </div>
                </div>
                <div id="uniquenessResults"></div>
            </div>

            <!-- Results and Preview -->
            <div class="wrangling-section">
                <h3>üìÑ Processed Data Preview</h3>
                <div id="wranglingPreview"></div>
            </div>
        </div>

        <!-- Statistics Tab -->
        <div id="statistics" class="tab-content">
            <h2>üìà Statistical Analysis</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="statSheet">Select Sheet:</label>
                    <select id="statSheet" onchange="updateStatistics()"></select>
                </div>
            </div>
            <div id="statisticsContent"></div>
        </div>

        <!-- Charts Tab -->
        <div id="charts" class="tab-content">
            <h2>üìä Data Visualization</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="chartSheet">Select Sheet:</label>
                    <select id="chartSheet" onchange="updateChartColumns()"></select>
                </div>
                <div class="control-group">
                    <label for="chartType">Chart Type:</label>
                    <select id="chartType">
                        <option value="bar">Bar Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="scatter">Scatter Plot</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="xAxis">X-Axis:</label>
                    <select id="xAxis"></select>
                </div>
                <div class="control-group">
                    <label for="yAxis">Y-Axis:</label>
                    <select id="yAxis"></select>
                </div>
                <div class="control-group" style="display: flex; align-items: end;">
                    <button class="btn" onclick="generateChart()">Generate Chart</button>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="dataChart"></canvas>
            </div>
        </div>

        <!-- Pivot Analysis Tab -->
        <div id="pivot" class="tab-content">
            <h2>üîÑ Pivot Table Analysis</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="pivotSheet">Select Sheet:</label>
                    <select id="pivotSheet" onchange="updatePivotColumns()"></select>
                </div>
                <div class="control-group">
                    <label for="pivotRows">Group By (Rows):</label>
                    <select id="pivotRows"></select>
                </div>
                <div class="control-group">
                    <label for="pivotValues">Values:</label>
                    <select id="pivotValues"></select>
                </div>
                <div class="control-group">
                    <label for="pivotAggregation">Aggregation:</label>
                    <select id="pivotAggregation">
                        <option value="sum">Sum</option>
                        <option value="average">Average</option>
                        <option value="count">Count</option>
                        <option value="min">Minimum</option>
                        <option value="max">Maximum</option>
                    </select>
                </div>
                <div class="control-group" style="display: flex; align-items: end;">
                    <button class="btn" onclick="generatePivotTable()">Generate Pivot</button>
                </div>
            </div>
            <div id="pivotResults"></div>
        </div>

        <!-- Export Tab -->
        <div id="export" class="tab-content">
            <h2>üíæ Export Data</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="exportSheet">Select Sheet:</label>
                    <select id="exportSheet"></select>
                </div>
                <div class="control-group">
                    <label for="exportFormat">Export Format:</label>
                    <select id="exportFormat">
                        <option value="excel">Excel (.xlsx)</option>
                        <option value="csv">CSV (.csv)</option>
                        <option value="json">JSON (.json)</option>
                    </select>
                </div>
                <div class="control-group" style="display: flex; align-items: end; gap: 10px;">
                    <button class="btn" onclick="exportData()">Download</button>
                    <button class="btn btn-secondary" onclick="exportChartAsImage()">Export Chart as PNG</button>
                </div>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>üìÑ Total Sheets</h3>
                    <div class="stat-value" id="totalSheets">0</div>
                </div>
                <div class="stat-card">
                    <h3>üìä Total Rows</h3>
                    <div class="stat-value" id="totalRows">0</div>
                </div>
                <div class="stat-card">
                    <h3>üìã Total Columns</h3>
                    <div class="stat-value" id="totalColumns">0</div>
                </div>
                <div class="stat-card">
                    <h3>üíæ File Size</h3>
                    <div class="stat-value" id="fileSize">0 KB</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let workbookData = {};
        let currentChart = null;
        let processedData = {};

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');

        // Initialize drag and drop functionality
        function initializeFileUpload() {
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                handleFiles(files);
            });

            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
        }

        function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                showError('Please select a valid Excel file (.xlsx or .xls)');
                return;
            }

            if (file.size > 50 * 1024 * 1024) {
                showError('File size must be less than 50MB');
                return;
            }

            processExcelFile(file);
        }

        function processExcelFile(file) {
            const reader = new FileReader();
            
            fileInfo.innerHTML = '<div class="loading">Processing file...</div>';
            fileInfo.style.display = 'block';

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    workbookData = {};
                    let totalRows = 0;
                    let totalColumns = 0;

                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        
                        // Filter out empty rows
                        const filteredData = jsonData.filter(row => row.some(cell => cell !== undefined && cell !== ''));
                        
                        if (filteredData.length > 0) {
                            workbookData[sheetName] = filteredData;
                            totalRows += filteredData.length;
                            totalColumns = Math.max(totalColumns, Math.max(...filteredData.map(row => row.length)));
                        }
                    });

                    // Update file info
                    fileInfo.innerHTML = `
                        <div class="success">
                            <strong>‚úÖ File loaded successfully!</strong><br>
                            üìÅ ${file.name} (${formatFileSize(file.size)})<br>
                            üìÑ ${Object.keys(workbookData).length} sheets, ${totalRows} rows, ${totalColumns} columns
                        </div>
                    `;

                    // Update export stats
                    document.getElementById('totalSheets').textContent = Object.keys(workbookData).length;
                    document.getElementById('totalRows').textContent = totalRows.toLocaleString();
                    document.getElementById('totalColumns').textContent = totalColumns;
                    document.getElementById('fileSize').textContent = formatFileSize(file.size);

                    // Populate sheet dropdowns
                    populateSheetDropdowns();
                    
                    // Show data preview
                    showDataPreview();
                    
                } catch (error) {
                    showError('Error processing file: ' + error.message);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function populateSheetDropdowns() {
            const sheetNames = Object.keys(workbookData);
            const dropdowns = ['statSheet', 'chartSheet', 'pivotSheet', 'exportSheet', 'wranglingSheet'];
            
            dropdowns.forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    sheetNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                }
            });

            if (sheetNames.length > 0) {
                updateStatistics();
                updateChartColumns();
                updatePivotColumns();
                updateWranglingSheet();
            }
        }

        function showDataPreview() {
            const previewDiv = document.getElementById('dataPreview');
            const sheetNames = Object.keys(workbookData);
            
            if (sheetNames.length === 0) {
                previewDiv.innerHTML = '<p>No data to display</p>';
                return;
            }

            let html = '';
            sheetNames.forEach(sheetName => {
                const data = workbookData[sheetName];
                const maxRows = Math.min(data.length, 10);
                
                html += `
                    <h3>üìÑ ${sheetName}</h3>
                    <div class="data-table">
                        <table>
                            <thead>
                                <tr>
                `;
                
                // Headers
                if (data.length > 0) {
                    const maxCols = Math.min(data[0].length, 10);
                    for (let i = 0; i < maxCols; i++) {
                        html += `<th>${data[0][i] || `Column ${i+1}`}</th>`;
                    }
                    if (data[0].length > 10) {
                        html += '<th>...</th>';
                    }
                }
                
                html += `
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Data rows
                for (let i = 1; i < maxRows; i++) {
                    if (data[i]) {
                        html += '<tr>';
                        const maxCols = Math.min(data[i].length, 10);
                        for (let j = 0; j < maxCols; j++) {
                            html += `<td>${data[i][j] || ''}</td>`;
                        }
                        if (data[i].length > 10) {
                            html += '<td>...</td>';
                        }
                        html += '</tr>';
                    }
                }
                
                if (data.length > 10) {
                    html += '<tr><td colspan="100%" style="text-align: center; font-style: italic;">... and more rows</td></tr>';
                }
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <br>
                `;
            });
            
            previewDiv.innerHTML = html;
        }

        // Data Wrangling Functions
        function updateWranglingSheet() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName || !workbookData[sheetName]) return;

            const headers = workbookData[sheetName][0] || [];
            
            // Update all column dropdowns
            const columnDropdowns = [
                'renameColumn', 'sortColumn', 'valueColumn', 'dateColumn', 
                'outlierColumn', 'groupByColumn', 'groupByCol', 'aggregateCol', 'uniqueColumn'
            ];
            
            columnDropdowns.forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    if (id === 'groupByColumn') {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No Grouping';
                        select.appendChild(option);
                    }
                    headers.forEach(header => {
                        const option = document.createElement('option');
                        option.value = header;
                        option.textContent = header;
                        select.appendChild(option);
                    });
                }
            });

            showWranglingPreview();
        }

        function showWranglingPreview() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            // Use processed data if available, otherwise use original
            const data = processedData[sheetName] || workbookData[sheetName];
            if (!data || data.length === 0) return;

            const maxRows = Math.min(data.length, 10);
            let html = `
                <div class="data-table">
                    <table>
                        <thead><tr>
            `;
            
            // Headers
            if (data.length > 0) {
                const maxCols = Math.min(data[0].length, 10);
                for (let i = 0; i < maxCols; i++) {
                    html += `<th>${data[0][i] || `Column ${i+1}`}</th>`;
                }
                if (data[0].length > 10) html += '<th>...</th>';
            }
            
            html += `</tr></thead><tbody>`;
            
            // Data rows
            for (let i = 1; i < maxRows; i++) {
                if (data[i]) {
                    html += '<tr>';
                    const maxCols = Math.min(data[i].length, 10);
                    for (let j = 0; j < maxCols; j++) {
                        html += `<td>${data[i][j] || ''}</td>`;
                    }
                    if (data[i].length > 10) html += '<td>...</td>';
                    html += '</tr>';
                }
            }
            
            if (data.length > 10) {
                html += '<tr><td colspan="100%" style="text-align: center; font-style: italic;">... and more rows</td></tr>';
            }
            
            html += '</tbody></table></div>';
            document.getElementById('wranglingPreview').innerHTML = html;
        }

        function runDataQualityCheck() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            const data = processedData[sheetName] || workbookData[sheetName];
            const headers = data[0];
            const rows = data.slice(1);

            let issues = [];
            let summary = { totalRows: rows.length, totalColumns: headers.length };

            // Check for leading/trailing spaces
            let spaceIssues = 0;
            rows.forEach(row => {
                row.forEach((cell, index) => {
                    if (typeof cell === 'string' && (cell !== cell.trim())) {
                        spaceIssues++;
                    }
                });
            });

            if (spaceIssues > 0) {
                issues.push(`${spaceIssues} cells have leading/trailing spaces`);
            }

            // Check for special characters
            let specialCharIssues = 0;
            rows.forEach(row => {
                row.forEach(cell => {
                    if (typeof cell === 'string' && /[.?/]/.test(cell)) {
                        specialCharIssues++;
                    }
                });
            });

            if (specialCharIssues > 0) {
                issues.push(`${specialCharIssues} cells contain special characters (.?/)`);
            }

            // Check for unnamed columns
            let unnamedCols = headers.filter(h => !h || h.includes('Unnamed') || h.includes('Column')).length;
            if (unnamedCols > 0) {
                issues.push(`${unnamedCols} unnamed columns found`);
            }

            // Check for accented characters
            let accentIssues = 0;
            rows.forEach(row => {
                row.forEach(cell => {
                    if (typeof cell === 'string' && /[√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√ø]/i.test(cell)) {
                        accentIssues++;
                    }
                });
            });

            if (accentIssues > 0) {
                issues.push(`${accentIssues} cells contain accented characters`);
            }

            let html = `
                <div class="outlier-summary">
                    <h4>üìä Data Quality Summary</h4>
                    <p><strong>Total Rows:</strong> ${summary.totalRows}</p>
                    <p><strong>Total Columns:</strong> ${summary.totalColumns}</p>
                    <p><strong>Issues Found:</strong> ${issues.length}</p>
                </div>
            `;

            if (issues.length > 0) {
                html += '<div class="quality-issue"><h4>‚ö†Ô∏è Issues Found:</h4><ul>';
                issues.forEach(issue => {
                    html += `<li>${issue}</li>`;
                });
                html += '</ul></div>';
            } else {
                html += '<div class="quality-pass">‚úÖ No data quality issues found!</div>';
            }

            document.getElementById('dataQualityResults').innerHTML = html;
        }

        function detectDataTypes() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            const data = processedData[sheetName] || workbookData[sheetName];
            const headers = data[0];
            const rows = data.slice(1);

            let html = `
                <div class="outlier-summary">
                    <h4>üîç Data Type Analysis</h4>
                </div>
                <div class="data-type-grid">
            `;

            headers.forEach((header, index) => {
                const columnData = rows.map(row => row[index]).filter(val => val !== undefined && val !== '');
                const analysis = analyzeDataType(columnData);
                
                html += `
                    <div class="data-type-card">
                        <h4>${header}</h4>
                        <p><strong>Detected Type:</strong> ${analysis.type}</p>
                        <p><strong>Confidence:</strong> ${analysis.confidence}%</p>
                        <p><strong>Issues:</strong> ${analysis.issues.length || 'None'}</p>
                        ${analysis.issues.length > 0 ? `<ul>${analysis.issues.map(issue => `<li>${issue}</li>`).join('')}</ul>` : ''}
                        ${analysis.convertible ? `<button class="btn btn-secondary" onclick="convertColumnType('${header}', '${analysis.recommendedType}')">Convert to ${analysis.recommendedType}</button>` : ''}
                    </div>
                `;
            });

            html += '</div>';
            document.getElementById('dataQualityResults').innerHTML = html;
        }

        function analyzeDataType(columnData) {
            if (columnData.length === 0) {
                return { type: 'Empty', confidence: 100, issues: [], convertible: false };
            }

            let numCount = 0;
            let dateCount = 0;
            let boolCount = 0;
            let issues = [];

            columnData.forEach(val => {
                const strVal = String(val).trim();
                
                // Check if numeric
                if (!isNaN(strVal) && strVal !== '') {
                    numCount++;
                } else if (isNaN(strVal) && /^\d+$/.test(strVal.replace(/[,\s]/g, ''))) {
                    numCount++;
                    issues.push('Numbers with formatting (commas, spaces)');
                }
                
                // Check if date
                if (isValidDate(strVal)) {
                    dateCount++;
                }
                
                // Check if boolean
                if (['true', 'false', 'yes', 'no', '1', '0'].includes(strVal.toLowerCase())) {
                    boolCount++;
                }
            });

            const total = columnData.length;
            const numPercent = (numCount / total) * 100;
            const datePercent = (dateCount / total) * 100;
            const boolPercent = (boolCount / total) * 100;

            let type, confidence, recommendedType, convertible = false;

            if (numPercent >= 80) {
                type = 'Numeric';
                confidence = Math.round(numPercent);
                if (numPercent < 100) {
                    recommendedType = 'Number';
                    convertible = true;
                }
            } else if (datePercent >= 80) {
                type = 'Date';
                confidence = Math.round(datePercent);
                recommendedType = 'Date';
                convertible = true;
            } else if (boolPercent >= 80) {
                type = 'Boolean';
                confidence = Math.round(boolPercent);
                recommendedType = 'Boolean';
                convertible = true;
            } else {
                type = 'Text';
                confidence = Math.round(Math.max(100 - numPercent - datePercent - boolPercent, 0));
            }

            return { type, confidence, issues: [...new Set(issues)], convertible, recommendedType };
        }

        function isValidDate(dateString) {
            const date = new Date(dateString);
            return date instanceof Date && !isNaN(date);
        }

        function trimSpaces() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            let changeCount = 0;

            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data[i].length; j++) {
                    if (typeof data[i][j] === 'string') {
                        const trimmed = data[i][j].trim();
                        if (trimmed !== data[i][j]) {
                            data[i][j] = trimmed;
                            changeCount++;
                        }
                    }
                }
            }

            showWranglingPreview();
            showMessage(`Trimmed spaces from ${changeCount} cells`, 'success');
        }

        function removeAccents() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            let changeCount = 0;

            const accentMap = {
                '√†': 'a', '√°': 'a', '√¢': 'a', '√£': 'a', '√§': 'a', '√•': 'a', '√¶': 'ae',
                '√®': 'e', '√©': 'e', '√™': 'e', '√´': 'e',
                '√¨': 'i', '√≠': 'i', '√Æ': 'i', '√Ø': 'i',
                '√≤': 'o', '√≥': 'o', '√¥': 'o', '√µ': 'o', '√∂': 'o', '√∏': 'o',
                '√π': 'u', '√∫': 'u', '√ª': 'u', '√º': 'u',
                '√Ω': 'y', '√ø': 'y',
                '√ß': 'c', '√±': 'n'
            };

            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data[i].length; j++) {
                    if (typeof data[i][j] === 'string') {
                        let original = data[i][j];
                        let cleaned = original.toLowerCase().split('').map(char => accentMap[char] || char).join('');
                        
                        // Preserve original case
                        let result = '';
                        for (let k = 0; k < original.length; k++) {
                            if (original[k] === original[k].toUpperCase()) {
                                result += cleaned[k] ? cleaned[k].toUpperCase() : cleaned[k];
                            } else {
                                result += cleaned[k] || '';
                            }
                        }
                        
                        if (result !== original) {
                            data[i][j] = result;
                            changeCount++;
                        }
                    }
                }
            }

            showWranglingPreview();
            showMessage(`Removed accents from ${changeCount} cells`, 'success');
        }

        function removeUnnamedColumns() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const indicesToRemove = [];

            // Find unnamed columns
            headers.forEach((header, index) => {
                if (!header || header.includes('Unnamed') || header.includes('Column') || header.trim() === '') {
                    indicesToRemove.push(index);
                }
            });

            // Remove columns from end to start to maintain indices
            indicesToRemove.reverse().forEach(index => {
                for (let i = 0; i < data.length; i++) {
                    data[i].splice(index, 1);
                }
            });

            showWranglingPreview();
            updateWranglingSheet(); // Update dropdown options
            showMessage(`Removed ${indicesToRemove.length} unnamed columns`, 'success');
        }

        function removeSpecialCharacters() {
            const sheetName = document.getElementById('wranglingSheet').value;
            if (!sheetName) return;

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            let changeCount = 0;

            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data[i].length; j++) {
                    if (typeof data[i][j] === 'string') {
                        const cleaned = data[i][j].replace(/[.?/]/g, '');
                        if (cleaned !== data[i][j]) {
                            data[i][j] = cleaned;
                            changeCount++;
                        }
                    }
                }
            }

            showWranglingPreview();
            showMessage(`Removed special characters from ${changeCount} cells`, 'success');
        }

        function renameColumn() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const oldName = document.getElementById('renameColumn').value;
            const newName = document.getElementById('newColumnName').value;

            if (!sheetName || !oldName || !newName) {
                showError('Please fill all fields');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(oldName);

            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            headers[columnIndex] = newName;
            updateWranglingSheet();
            showWranglingPreview();
            showMessage(`Renamed column "${oldName}" to "${newName}"`, 'success');
        }

        function sortByColumn() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('sortColumn').value;
            const order = document.getElementById('sortOrder').value;

            if (!sheetName || !columnName) {
                showError('Please select sheet and column');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);

            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            const dataRows = data.slice(1);
            dataRows.sort((a, b) => {
                const aVal = a[columnIndex];
                const bVal = b[columnIndex];
                
                if (order === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });

            processedData[sheetName] = [headers, ...dataRows];
            showWranglingPreview();
            showMessage(`Sorted by "${columnName}" in ${order}ending order`, 'success');
        }

        function replaceValues() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('valueColumn').value;
            const oldValue = document.getElementById('oldValue').value;
            const newValue = document.getElementById('newValue').value;

            if (!sheetName || !columnName || oldValue === '') {
                showError('Please fill all required fields');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);

            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            let replaceCount = 0;
            for (let i = 1; i < data.length; i++) {
                if (String(data[i][columnIndex]) === String(oldValue)) {
                    data[i][columnIndex] = newValue;
                    replaceCount++;
                }
            }

            showWranglingPreview();
            showMessage(`Replaced ${replaceCount} instances of "${oldValue}" with "${newValue}" in column "${columnName}"`, 'success');
        }

        function standardizeDates() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('dateColumn').value;
            const targetFormat = document.getElementById('dateFormat').value;

            if (!sheetName || !columnName) {
                showError('Please select sheet and column');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);

            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            let convertCount = 0;
            let errorCount = 0;

            for (let i = 1; i < data.length; i++) {
                const originalValue = data[i][columnIndex];
                if (originalValue) {
                    try {
                        const date = new Date(originalValue);
                        if (!isNaN(date)) {
                            let formattedDate;
                            
                            switch (targetFormat) {
                                case 'yyyy-mm-dd':
                                    formattedDate = date.toISOString().split('T')[0];
                                    break;
                                case 'dd/mm/yyyy':
                                    formattedDate = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;
                                    break;
                                case 'mm/dd/yyyy':
                                    formattedDate = `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}/${date.getFullYear()}`;
                                    break;
                                case 'dd-mm-yyyy':
                                    formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
                                    break;
                                case 'iso':
                                    formattedDate = date.toISOString();
                                    break;
                            }
                            
                            data[i][columnIndex] = formattedDate;
                            convertCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (e) {
                        errorCount++;
                    }
                }
            }

            showWranglingPreview();
            showMessage(`Standardized ${convertCount} dates. ${errorCount} errors encountered.`, 'success');
        }

        function checkUniqueness() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('uniqueColumn').value;
            
            if (!sheetName || !columnName) {
                showError('Please select sheet and column');
                return;
            }

            const data = processedData[sheetName] || workbookData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);
            
            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            const values = data.slice(1)
                .map(row => row[columnIndex])
                .filter(val => val !== undefined && val !== '');

            const uniqueValues = [...new Set(values)].sort();
            const duplicates = values.filter((item, index) => values.indexOf(item) !== index);
            const duplicateCounts = {};
            
            duplicates.forEach(item => {
                duplicateCounts[item] = (duplicateCounts[item] || 0) + 1;
            });

            let html = `
                <div class="outlier-summary">
                    <h4>üìä Uniqueness Analysis for "${columnName}"</h4>
                    <p><strong>Total Values:</strong> ${values.length}</p>
                    <p><strong>Unique Values:</strong> ${uniqueValues.length}</p>
                    <p><strong>Duplicates:</strong> ${Object.keys(duplicateCounts).length} unique duplicated values</p>
                </div>
            `;

            if (uniqueValues.length > 0) {
                html += `
                    <div class="data-table">
                        <h4>üî§ Unique Values (Alphabetical Order)</h4>
                        <table>
                            <thead><tr><th>Value</th><th>Count</th></tr></thead>
                            <tbody>
                `;
                
                uniqueValues.forEach(value => {
                    const count = values.filter(v => v === value).length;
                    const rowClass = count > 1 ? 'style="background-color: #fff3cd;"' : '';
                    html += `<tr ${rowClass}><td>${value}</td><td>${count}</td></tr>`;
                });
                
                html += '</tbody></table></div>';
            }

            if (Object.keys(duplicateCounts).length > 0) {
                html += `
                    <div class="quality-issue">
                        <h4>‚ö†Ô∏è Duplicate Values Found</h4>
                        <ul>
                `;
                Object.entries(duplicateCounts).forEach(([value, count]) => {
                    html += `<li>"${value}" appears ${count + 1} times</li>`;
                });
                html += '</ul></div>';
            }

            document.getElementById('uniquenessResults').innerHTML = html;
        }

        function findSimilarValues() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('uniqueColumn').value;
            const threshold = parseFloat(document.getElementById('similarityThreshold').value);
            
            if (!sheetName || !columnName) {
                showError('Please select sheet and column');
                return;
            }

            const data = processedData[sheetName] || workbookData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);
            
            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            const values = [...new Set(data.slice(1)
                .map(row => row[columnIndex])
                .filter(val => val !== undefined && val !== '')
                .map(val => String(val)))];

            const similarPairs = [];
            
            for (let i = 0; i < values.length; i++) {
                for (let j = i + 1; j < values.length; j++) {
                    const similarity = calculateSimilarity(values[i], values[j]);
                    if (similarity >= threshold && similarity < 1) {
                        similarPairs.push({
                            value1: values[i],
                            value2: values[j],
                            similarity: similarity.toFixed(3)
                        });
                    }
                }
            }

            let html = `
                <div class="outlier-summary">
                    <h4>üîç Similarity Analysis for "${columnName}"</h4>
                    <p><strong>Threshold:</strong> ${threshold}</p>
                    <p><strong>Similar Pairs Found:</strong> ${similarPairs.length}</p>
                </div>
            `;

            if (similarPairs.length > 0) {
                html += `
                    <div class="data-table">
                        <h4>üîç Potentially Similar Values</h4>
                        <p style="color: #856404; background: #fff3cd; padding: 10px; border-radius: 5px;">
                            ‚ö†Ô∏è These values might be misspelled or duplicated. Please review for potential data cleaning.
                        </p>
                        <table>
                            <thead><tr><th>Value 1</th><th>Value 2</th><th>Similarity</th><th>Action</th></tr></thead>
                            <tbody>
                `;
                
                similarPairs.forEach((pair, index) => {
                    html += `
                        <tr>
                            <td>${pair.value1}</td>
                            <td>${pair.value2}</td>
                            <td>${pair.similarity}</td>
                            <td>
                                <button class="btn btn-secondary" style="font-size: 12px; padding: 5px 10px;" 
                                        onclick="replaceSimilarValue('${columnName}', '${pair.value1}', '${pair.value2}')">
                                    Replace "${pair.value1}" ‚Üí "${pair.value2}"
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table></div>';
            } else {
                html += '<div class="quality-pass">‚úÖ No similar values found above the threshold.</div>';
            }

            document.getElementById('uniquenessResults').innerHTML = html;
        }

        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function replaceSimilarValue(columnName, oldValue, newValue) {
            const sheetName = document.getElementById('wranglingSheet').value;
            document.getElementById('valueColumn').value = columnName;
            document.getElementById('oldValue').value = oldValue;
            document.getElementById('newValue').value = newValue;
            replaceValues();
        }

        function handleOutliers() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const columnName = document.getElementById('outlierColumn').value;
            const method = document.getElementById('outlierMethod').value;
            const action = document.getElementById('outlierAction').value;
            const groupBy = document.getElementById('groupByColumn').value;

            if (!sheetName || !columnName) {
                showError('Please select sheet and column');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const columnIndex = headers.indexOf(columnName);
            const groupIndex = groupBy ? headers.indexOf(groupBy) : -1;

            if (columnIndex === -1) {
                showError('Column not found');
                return;
            }

            let results;
            if (groupIndex !== -1) {
                results = handleOutliersByGroup(data, columnIndex, groupIndex, method, action);
            } else {
                results = handleOutliersGlobal(data, columnIndex, method, action);
            }

            showOutlierResults(results, columnName, method, action, groupBy);
            showWranglingPreview();
        }

        function handleOutliersGlobal(data, columnIndex, method, action) {
            const values = data.slice(1)
                .map((row, index) => ({ value: parseFloat(row[columnIndex]), rowIndex: index + 1 }))
                .filter(item => !isNaN(item.value));

            const outliers = detectOutliers(values.map(v => v.value), method);
            const outlierIndices = values.filter(v => outliers.includes(v.value)).map(v => v.rowIndex);

            let beforeCount = values.length;
            let afterCount = beforeCount;
            let corrections = [];

            if (action !== 'detect') {
                outlierIndices.reverse().forEach(rowIndex => {
                    const originalValue = data[rowIndex][columnIndex];
                    
                    switch (action) {
                        case 'remove':
                            data.splice(rowIndex, 1);
                            afterCount--;
                            corrections.push({
                                row: rowIndex,
                                before: originalValue,
                                after: 'Removed'
                            });
                            break;
                        case 'cap':
                            const sortedValues = values.map(v => v.value).sort((a, b) => a - b);
                            const q1 = sortedValues[Math.floor(sortedValues.length * 0.25)];
                            const q3 = sortedValues[Math.floor(sortedValues.length * 0.75)];
                            const newValue = originalValue < q1 ? q1 : q3;
                            data[rowIndex][columnIndex] = newValue;
                            corrections.push({
                                row: rowIndex,
                                before: originalValue,
                                after: newValue
                            });
                            break;
                        case 'median':
                            const median = calculateMedian(values.map(v => v.value));
                            data[rowIndex][columnIndex] = median;
                            corrections.push({
                                row: rowIndex,
                                before: originalValue,
                                after: median
                            });
                            break;
                    }
                });
            }

            return {
                method,
                action,
                outliers: outliers.length,
                beforeCount,
                afterCount,
                corrections,
                groupBy: null
            };
        }

        function detectOutliers(values, method) {
            switch (method) {
                case 'iqr':
                    return detectOutliersIQR(values);
                case 'zscore':
                    return detectOutliersZScore(values);
                case 'modified_zscore':
                    return detectOutliersModifiedZScore(values);
                default:
                    return [];
            }
        }

        function detectOutliersIQR(values) {
            const sorted = values.slice().sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            
            return values.filter(v => v < lowerBound || v > upperBound);
        }

        function detectOutliersZScore(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            
            return values.filter(v => Math.abs((v - mean) / stdDev) > 3);
        }

        function detectOutliersModifiedZScore(values) {
            const median = calculateMedian(values);
            const deviations = values.map(v => Math.abs(v - median));
            const mad = calculateMedian(deviations);
            
            return values.filter(v => Math.abs(0.6745 * (v - median) / mad) > 3.5);
        }

        function calculateMedian(values) {
            const sorted = values.slice().sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }

        function showOutlierResults(results, columnName, method, action, groupBy) {
            let html = `
                <div class="outlier-summary">
                    <h4>üìä Outlier Analysis Results</h4>
                    <p><strong>Column:</strong> ${columnName}</p>
                    <p><strong>Method:</strong> ${method.toUpperCase()}</p>
                    <p><strong>Action:</strong> ${action}</p>
                    ${groupBy ? `<p><strong>Grouped by:</strong> ${groupBy}</p>` : '<p><strong>Analysis:</strong> Global (no grouping)</p>'}
                    <p><strong>Outliers Found:</strong> ${results.outliers}</p>
                    <p><strong>Before:</strong> ${results.beforeCount} values</p>
                    <p><strong>After:</strong> ${results.afterCount} values</p>
                </div>
            `;

            if (results.corrections.length > 0) {
                html += `
                    <div class="data-table">
                        <h4>üîß Corrections Applied</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Row</th>
                                    ${groupBy ? '<th>Group</th>' : ''}
                                    <th>Before</th>
                                    <th>After</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                results.corrections.slice(0, 20).forEach(correction => {
                    html += `
                        <tr>
                            <td>${correction.row}</td>
                            ${groupBy ? `<td>${correction.group || ''}</td>` : ''}
                            <td>${correction.before}</td>
                            <td>${correction.after}</td>
                        </tr>
                    `;
                });
                
                if (results.corrections.length > 20) {
                    html += `<tr><td colspan="100%" style="text-align: center; font-style: italic;">... and ${results.corrections.length - 20} more corrections</td></tr>`;
                }
                
                html += '</tbody></table></div>';
            }

            document.getElementById('outlierResults').innerHTML = html;
        }

        function createAggregateColumn() {
            const sheetName = document.getElementById('wranglingSheet').value;
            const newColName = document.getElementById('newColName').value;
            const groupByCol = document.getElementById('groupByCol').value;
            const aggregateCol = document.getElementById('aggregateCol').value;
            const aggregateFunction = document.getElementById('aggregateFunction').value;

            if (!sheetName || !newColName || !groupByCol || !aggregateCol) {
                showError('Please fill all required fields');
                return;
            }

            if (!processedData[sheetName]) {
                processedData[sheetName] = JSON.parse(JSON.stringify(workbookData[sheetName]));
            }

            const data = processedData[sheetName];
            const headers = data[0];
            const groupIndex = headers.indexOf(groupByCol);
            const aggIndex = headers.indexOf(aggregateCol);

            if (groupIndex === -1 || aggIndex === -1) {
                showError('Selected columns not found');
                return;
            }

            // Add new column header
            headers.push(newColName);
            const newColIndex = headers.length - 1;

            // Group data and calculate aggregates
            const groups = {};
            const rows = data.slice(1);

            rows.forEach(row => {
                const groupValue = row[groupIndex];
                const aggValue = parseFloat(row[aggIndex]);
                
                if (!groups[groupValue]) {
                    groups[groupValue] = [];
                }
                if (!isNaN(aggValue)) {
                    groups[groupValue].push(aggValue);
                }
            });

            // Calculate aggregates
            const aggregates = {};
            Object.keys(groups).forEach(groupValue => {
                const values = groups[groupValue];
                let result;
                
                switch (aggregateFunction) {
                    case 'sum':
                        result = values.reduce((a, b) => a + b, 0);
                        break;
                    case 'average':
                        result = values.reduce((a, b) => a + b, 0) / values.length;
                        break;
                    case 'count':
                        result = values.length;
                        break;
                    case 'min':
                        result = Math.min(...values);
                        break;
                    case 'max':
                        result = Math.max(...values);
                        break;
                    case 'percentage':
                        const total = Object.values(groups).flat().reduce((a, b) => a + b, 0);
                        result = (values.reduce((a, b) => a + b, 0) / total) * 100;
                        break;
                }
                
                aggregates[groupValue] = result;
            });

            // Add calculated values to each row
            rows.forEach(row => {
                const groupValue = row[groupIndex];
                row[newColIndex] = aggregates[groupValue] || 0;
            });

            updateWranglingSheet();
            showWranglingPreview();
            showMessage(`Created new column "${newColName}" with ${aggregateFunction} of ${aggregateCol} grouped by ${groupByCol}`, 'success');
        }

        // Statistics Functions
        function updateStatistics() {
            const sheetName = document.getElementById('statSheet').value;
            if (!sheetName || !workbookData[sheetName]) return;

            const data = workbookData[sheetName];
            const headers = data[0] || [];
            const rows = data.slice(1);

            let html = '<div class="stats-grid">';
            
            // Basic statistics
            html += `
                <div class="stat-card">
                    <h3>üìä Total Rows</h3>
                    <div class="stat-value">${rows.length.toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <h3>üìã Total Columns</h3>
                    <div class="stat-value">${headers.length}</div>
                </div>
            `;

            // Column analysis
            headers.forEach((header, index) => {
                const columnData = rows.map(row => row[index]).filter(val => val !== undefined && val !== '');
                
                if (columnData.length > 0) {
                    const isNumeric = columnData.every(val => !isNaN(val) && val !== '');
                    
                    if (isNumeric) {
                        const numbers = columnData.map(Number);
                        const sum = numbers.reduce((a, b) => a + b, 0);
                        const avg = sum / numbers.length;
                        const min = Math.min(...numbers);
                        const max = Math.max(...numbers);
                        
                        html += `
                            <div class="stat-card">
                                <h3>üî¢ ${header}</h3>
                                <div>Count: <strong>${numbers.length}</strong></div>
                                <div>Sum: <strong>${sum.toLocaleString()}</strong></div>
                                <div>Average: <strong>${avg.toFixed(2)}</strong></div>
                                <div>Min: <strong>${min}</strong></div>
                                <div>Max: <strong>${max}</strong></div>
                            </div>
                        `;
                    } else {
                        const unique = [...new Set(columnData)].length;
                        html += `
                            <div class="stat-card">
                                <h3>üìù ${header}</h3>
                                <div>Count: <strong>${columnData.length}</strong></div>
                                <div>Unique: <strong>${unique}</strong></div>
                                <div>Fill Rate: <strong>${((columnData.length / rows.length) * 100).toFixed(1)}%</strong></div>
                            </div>
                        `;
                    }
                }
            });

            html += '</div>';
            document.getElementById('statisticsContent').innerHTML = html;
        }

        // Chart Functions
        function updateChartColumns() {
            const sheetName = document.getElementById('chartSheet').value;
            if (!sheetName || !workbookData[sheetName]) return;

            const headers = workbookData[sheetName][0] || [];
            const xAxis = document.getElementById('xAxis');
            const yAxis = document.getElementById('yAxis');

            xAxis.innerHTML = '';
            yAxis.innerHTML = '';

            headers.forEach(header => {
                const optionX = document.createElement('option');
                optionX.value = header;
                optionX.textContent = header;
                xAxis.appendChild(optionX);

                const optionY = document.createElement('option');
                optionY.value = header;
                optionY.textContent = header;
                yAxis.appendChild(optionY);
            });
        }

        function generateChart() {
            const sheetName = document.getElementById('chartSheet').value;
            const chartType = document.getElementById('chartType').value;
            const xAxisCol = document.getElementById('xAxis').value;
            const yAxisCol = document.getElementById('yAxis').value;

            if (!sheetName || !workbookData[sheetName] || !xAxisCol || !yAxisCol) {
                showError('Please select all required fields for chart generation');
                return;
            }

            const data = workbookData[sheetName];
            const headers = data[0];
            const rows = data.slice(1);

            const xIndex = headers.indexOf(xAxisCol);
            const yIndex = headers.indexOf(yAxisCol);

            if (xIndex === -1 || yIndex === -1) {
                showError('Selected columns not found');
                return;
            }

            // Prepare chart data
            const chartData = rows
                .filter(row => row[xIndex] !== undefined && row[yIndex] !== undefined)
                .map(row => ({
                    x: row[xIndex],
                    y: parseFloat(row[yIndex]) || 0
                }));

            // Group data for certain chart types
            let processedData = chartData;
            if (chartType === 'pie' || chartType === 'bar') {
                const grouped = _.groupBy(chartData, 'x');
                processedData = Object.keys(grouped).map(key => ({
                    x: key,
                    y: _.sumBy(grouped[key], 'y')
                }));
            }

            const ctx = document.getElementById('dataChart').getContext('2d');
            
            if (currentChart) {
                currentChart.destroy();
            }

            const config = {
                type: chartType,
                data: {
                    labels: processedData.map(item => item.x),
                    datasets: [{
                        label: yAxisCol,
                        data: processedData.map(item => item.y),
                        backgroundColor: generateColors(processedData.length),
                        borderColor: generateColors(processedData.length, 0.8),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yAxisCol} by ${xAxisCol}`
                        },
                        legend: {
                            display: chartType === 'pie'
                        }
                    },
                    scales: chartType !== 'pie' ? {
                        x: {
                            title: {
                                display: true,
                                text: xAxisCol
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yAxisCol
                            }
                        }
                    } : {}
                }
            };

            currentChart = new Chart(ctx, config);
        }

        // Pivot Functions
        function updatePivotColumns() {
            const sheetName = document.getElementById('pivotSheet').value;
            if (!sheetName || !workbookData[sheetName]) return;

            const headers = workbookData[sheetName][0] || [];
            const pivotRows = document.getElementById('pivotRows');
            const pivotValues = document.getElementById('pivotValues');

            pivotRows.innerHTML = '';
            pivotValues.innerHTML = '';

            headers.forEach(header => {
                const optionR = document.createElement('option');
                optionR.value = header;
                optionR.textContent = header;
                pivotRows.appendChild(optionR);

                const optionV = document.createElement('option');
                optionV.value = header;
                optionV.textContent = header;
                pivotValues.appendChild(optionV);
            });
        }

        function generatePivotTable() {
            const sheetName = document.getElementById('pivotSheet').value;
            const rowsCol = document.getElementById('pivotRows').value;
            const valuesCol = document.getElementById('pivotValues').value;
            const aggregation = document.getElementById('pivotAggregation').value;

            if (!sheetName || !workbookData[sheetName] || !rowsCol || !valuesCol) {
                showError('Please select all required fields for pivot table');
                return;
            }

            const data = workbookData[sheetName];
            const headers = data[0];
            const rows = data.slice(1);

            const rowIndex = headers.indexOf(rowsCol);
            const valueIndex = headers.indexOf(valuesCol);

            if (rowIndex === -1 || valueIndex === -1) {
                showError('Selected columns not found');
                return;
            }

            // Group data
            const grouped = _.groupBy(rows.filter(row => 
                row[rowIndex] !== undefined && row[valueIndex] !== undefined
            ), row => row[rowIndex]);

            // Calculate aggregations
            const pivotData = Object.keys(grouped).map(key => {
                const group = grouped[key];
                const values = group.map(row => parseFloat(row[valueIndex]) || 0);
                
                let aggregatedValue;
                switch (aggregation) {
                    case 'sum':
                        aggregatedValue = _.sum(values);
                        break;
                    case 'average':
                        aggregatedValue = _.mean(values);
                        break;
                    case 'count':
                        aggregatedValue = values.length;
                        break;
                    case 'min':
                        aggregatedValue = _.min(values);
                        break;
                    case 'max':
                        aggregatedValue = _.max(values);
                        break;
                    default:
                        aggregatedValue = _.sum(values);
                }

                return {
                    group: key,
                    value: aggregatedValue,
                    count: values.length
                };
            });

            // Generate table
            let html = `
                <div class="data-table">
                    <table>
                        <thead>
                            <tr>
                                <th>${rowsCol}</th>
                                <th>${aggregation.charAt(0).toUpperCase() + aggregation.slice(1)} of ${valuesCol}</th>
                                <th>Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            pivotData.forEach(row => {
                html += `
                    <tr>
                        <td>${row.group}</td>
                        <td>${typeof row.value === 'number' ? row.value.toLocaleString() : row.value}</td>
                        <td>${row.count}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('pivotResults').innerHTML = html;
        }

        // Export Functions
        function exportData() {
            const sheetName = document.getElementById('exportSheet').value;
            const format = document.getElementById('exportFormat').value;

            if (!sheetName || !workbookData[sheetName]) {
                showError('Please select a sheet to export');
                return;
            }

            const data = workbookData[sheetName];

            switch (format) {
                case 'excel':
                    exportAsExcel(data, sheetName);
                    break;
                case 'csv':
                    exportAsCSV(data, sheetName);
                    break;
                case 'json':
                    exportAsJSON(data, sheetName);
                    break;
            }
        }

        function exportAsExcel(data, sheetName) {
            const ws = XLSX.utils.aoa_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
            XLSX.writeFile(wb, `${sheetName}_export.xlsx`);
        }

        function exportAsCSV(data, sheetName) {
            const csv = data.map(row => row.map(cell => 
                typeof cell === 'string' && cell.includes(',') ? `"${cell}"` : cell
            ).join(',')).join('\n');
            
            downloadFile(csv, `${sheetName}_export.csv`, 'text/csv');
        }

        function exportAsJSON(data, sheetName) {
            const headers = data[0];
            const rows = data.slice(1);
            const jsonData = rows.map(row => {
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header] = row[index];
                });
                return obj;
            });
            
            downloadFile(JSON.stringify(jsonData, null, 2), `${sheetName}_export.json`, 'application/json');
        }

        function exportChartAsImage() {
            if (!currentChart) {
                showError('Please generate a chart first');
                return;
            }

            const canvas = document.getElementById('dataChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'chart_export.png';
            link.href = url;
            link.click();
        }

        // Utility Functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function generateColors(count, alpha = 0.7) {
            const colors = [
                `rgba(102, 126, 234, ${alpha})`,
                `rgba(118, 75, 162, ${alpha})`,
                `rgba(40, 167, 69, ${alpha})`,
                `rgba(255, 193, 7, ${alpha})`,
                `rgba(220, 53, 69, ${alpha})`,
                `rgba(23, 162, 184, ${alpha})`,
                `rgba(108, 117, 125, ${alpha})`,
                `rgba(253, 126, 20, ${alpha})`
            ];
            
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        function showError(message) {
            fileInfo.innerHTML = `<div class="error">‚ùå ${message}</div>`;
            fileInfo.style.display = 'block';
        }

        function showMessage(message, type) {
            const className = type === 'success' ? 'success' : 'error';
            fileInfo.innerHTML = `<div class="${className}">${type === 'success' ? '‚úÖ' : '‚ùå'} ${message}</div>`;
            fileInfo.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                fileInfo.style.display = 'none';
            }, 3000);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Data Management Tool loaded successfully');
            initializeFileUpload();
        });
    </script>
</body>
</html>
